#include <libutl/libutl.h>
#include <libutl/BitArray.h>
#include <libutl/MaxObject.h>
#include <libutl/Vector.h>

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_CLASS_IMPL_ABC(utl::Ordering);
UTL_CLASS_IMPL(utl::NaturalOrdering);
UTL_CLASS_IMPL(utl::InvertedNaturalOrdering);
UTL_CLASS_IMPL(utl::KeyOrdering);
UTL_CLASS_IMPL(utl::InvertedKeyOrdering);
UTL_CLASS_IMPL(utl::TypeOrdering);
UTL_CLASS_IMPL(utl::AddressOrdering);
UTL_CLASS_IMPL_ABC(utl::MultiKeyOrdering);

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_NS_BEGIN;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Ordering ///////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const Object&
Ordering::getObjectKey(const Object* object) const
{
    ASSERTD(object != nullptr);
    return *object;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// NaturalOrdering ////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const NaturalOrdering naturalOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
NaturalOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    ASSERTD((lhs != nullptr) && (rhs != nullptr));
    return lhs->compare(*rhs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// InvertedNaturalOrdering ////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const InvertedNaturalOrdering invertedNaturalOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
InvertedNaturalOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    ASSERTD((lhs != nullptr) && (rhs != nullptr));
    return rhs->compare(*lhs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// KeyOrdering ////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const KeyOrdering keyOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
KeyOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    ASSERTD((lhs != nullptr) && (rhs != nullptr));
    return lhs->getKey().compare(rhs->getKey());
}

////////////////////////////////////////////////////////////////////////////////////////////////////

const Object&
KeyOrdering::getObjectKey(const Object* object) const
{
    ASSERTD(object != nullptr);
    return object->getKey();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// InvertedKeyOrdering ////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const InvertedKeyOrdering invertedKeyOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
InvertedKeyOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    ASSERTD((lhs != nullptr) && (rhs != nullptr));
    return rhs->getKey().compare(lhs->getKey());
}

////////////////////////////////////////////////////////////////////////////////////////////////////

const Object&
InvertedKeyOrdering::getObjectKey(const Object* object) const
{
    ASSERTD(object != nullptr);
    return object->getKey();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOrdering ///////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const TypeOrdering typeOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
TypeOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    ASSERTD((lhs != nullptr) && (rhs != nullptr));

    // types don't match?
    const RunTimeClass* lhsRTC = lhs->getClass();
    const RunTimeClass* rhsRTC = rhs->getClass();
    ASSERTD((lhsRTC != nullptr) && (rhsRTC != nullptr));
    if (lhsRTC != rhsRTC)
    {
        int res = strcmp(lhsRTC->name(), rhsRTC->name());
        ASSERTD(res != 0);
        return res;
    }

    // use the ordering (or default to Object::compare)
    if (_ordering == nullptr)
        return lhs->compare(*rhs);
    return _ordering->cmp(lhs, rhs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// AddressOrdering ////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

const AddressOrdering addressOrdering;

////////////////////////////////////////////////////////////////////////////////////////////////////

int
AddressOrdering::cmp(const Object* lhs, const Object* rhs) const
{
    // compare addresses
    const void* lhsAddr;
    const void* rhsAddr;
    if (lhs->isA(Uint))
    {
        auto ptr = utl::cast<Uint>(lhs);
        lhsAddr = reinterpret_cast<void*>(ptr->get());
    }
    else
    {
        lhsAddr = lhs;
    }
    if (rhs->isA(Uint))
    {
        auto ptr = utl::cast<Uint>(rhs);
        rhsAddr = reinterpret_cast<void*>(ptr->get());
    }
    else
    {
        rhsAddr = rhs;
    }
    return utl::compare(lhsAddr, rhsAddr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// MultiKeyOrdering ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void
MultiKeyOrdering::copy(const Object& rhs)
{
    auto& mko = utl::cast<MultiKeyOrdering>(rhs);
    Ordering::copy(mko);
    _fieldIds = mko._fieldIds;
    _ascendingFlags = mko._ascendingFlags;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
MultiKeyOrdering::serialize(Stream& stream, uint_t io, uint_t mode)
{
    Ordering::serialize(stream, io, mode);
    _fieldIds->serialize(stream, io, mode);
    _ascendingFlags->serialize(stream, io, mode);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
MultiKeyOrdering::addKey(uint_t fieldId, bool ascending)
{
    _fieldIds->grow(_numKeys + 1);
    (*_fieldIds)[_numKeys] = fieldId;
    _ascendingFlags->grow(_numKeys + 1);
    _ascendingFlags->set(_numKeys, ascending ? 1 : 0);
    ++_numKeys;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

uint_t
MultiKeyOrdering::keyId(uint_t idx) const
{
    ASSERTD(idx < _numKeys);
    return (*_fieldIds)[(size_t)idx];
}

////////////////////////////////////////////////////////////////////////////////////////////////////

bool
MultiKeyOrdering::isAscending(uint_t idx) const
{
    ASSERTD(idx < _numKeys);
    return _ascendingFlags->get(idx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
MultiKeyOrdering::init()
{
    _numKeys = 0;
    _fieldIds = new Vector<uint_t>();
    _fieldIds->setIncrement(4);
    _ascendingFlags = new BitArray();
    _ascendingFlags->initialize(8, 1);
    _ascending = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
MultiKeyOrdering::deInit()
{
    delete _fieldIds;
    delete _ascendingFlags;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_NS_END;
