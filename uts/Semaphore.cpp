#include <libutl/libutl.h>
#include <libutl/Semaphore.h>

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_CLASS_IMPL(utl::Semaphore);

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_NS_BEGIN;

////////////////////////////////////////////////////////////////////////////////////////////////////

bool
Semaphore::trydown()
{
    bool res;
#if UTL_HOST_OS == UTL_HT_UNIX
    int err = sem_trywait(&_sem);
    res = (err == 0);
#else
    res = (WaitForSingleObject(_sem, 0) != uint_t_max);
#endif
    return res;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
Semaphore::down()
{
#if UTL_HOST_TYPE == UTL_HT_UNIX
    UTL_EINTR_LOOP(sem_wait(&_sem));
#else
    ASSERT(WaitForSingleObject(_sem, INFINITE) != uint_t_max);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
Semaphore::up()
{
#if UTL_HOST_TYPE == UTL_HT_UNIX
    ASSERTFNZ(sem_post(&_sem));
#else
    ASSERTFNP(ReleaseSemaphore(_sem, 1, nullptr));
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
Semaphore::init(uint_t count)
{
#if UTL_HOST_TYPE == UTL_HT_UNIX
    ASSERTFNZ(sem_init(&_sem, 0, count));
#else
    _sem = CreateSemaphore(nullptr, count, long_t_max, nullptr);
    ASSERT(_sem != nullptr);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void
Semaphore::deInit()
{
#if UTL_HOST_TYPE == UTL_HT_UNIX
    ASSERTFNZ(sem_destroy(&_sem));
#else
    ASSERTFNP(CloseHandle(_sem));
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////

UTL_NS_END;
